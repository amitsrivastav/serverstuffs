elasticsearch_hostname = process.env.ELASTICSEARCH_HOSTNAME || 'localhost:7200'elasticsearch_url = "http://" + elasticsearch_hostname + "/"print_result = (err,res,body,msg) ->  if(err)    msg.send err    msg.send res    msg.send body  else    data = JSON.parse body    logs = data.hits.hits.sort (a,b) -> if a._source.date > b._source.date then 1 else -1    msg.send "#{log._source.message}" for log in logssearch_logs = (msg, data) ->  data = JSON.stringify(data)  msg.http(elasticsearch_url + "docker-gelf-*/_search" )  .header('Content-Length', data.length)  .post(data) (err, res, body) ->    print_result(err, res, body, msg)module.exports = (robot) ->  robot.respond /get the logs for application (.*) from last (.*) days/i, (msg) ->     application_name = msg.match[1]     fromlastdays = "now-" + msg.match[2] + "d"     data = { query: { bool : { must : [ { term : {"container_name.keyword" : application_name } }, { range : { "@timestamp" : { "gte" : fromlastdays , "lt" :  "now" } } } ] }}}     search_logs(msg,data)  robot.respond /get the logs for application (.*) from last (.*) hours/i, (msg) ->     application_name = msg.match[1]     fromlasthours = "now-" + msg.match[2] + "h"     data = { query: { bool : { must : [ { term : {"container_name.keyword" : application_name } }, { range : { "@timestamp" : { "gte" : fromlasthours , "lt" :  "now" } } } ] }}}     search_logs(msg,data)  robot.respond /get the logs for application (.*) from last (.*) minutes/i, (msg) ->     application_name = msg.match[1]     fromlastminutes = "now-" + msg.match[2] + "m"     data = { query: { bool : { must : [ { term : {"container_name.keyword" : application_name } }, { range : { "@timestamp" : { "gte" : fromlastminutes , "lt" :  "now" } } } ] }}}     search_logs(msg,data)
